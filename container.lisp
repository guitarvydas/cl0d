(defun Container/new (given-name children connections)
  (let ((name (format nil "[Container ~a]" given-name)))
    (let ((eh (Eh/new name)))
      `((%tag . Container)
        (handle . ,(lambda (msg)
		     (route-downwards eh (%call msg 'port) (%call msg 'datum) connections)
                     (dispatch-until-quiescence children connections)))
	(%else . ,eh)))))

(defun dispatch-until-quiescence (children connections)
  (cond ((any-child-ready? children) 
         (dispatch-all-children-once children connections)
         (dispatch-until-quiescence children connections))
        (t nil)))

(defun dispatch-all-children-once (children connections)
  (mapc #'(lambda (child)
            (cond ((ready? child)
                   (let ((msg (pull-input child)))
                     (handle-input child msg)
                     (route-and-clear-outputs-from-single-child child connections)))
                  (t nil)))
        children))

(defun pull-input (e)
  (%call e 'dequeue-input))

(defun handle-input (child msg)
  (%call child 'handle msg))

(defun route-and-clear-outputs-from-single-child (child connections)
  (mapc #'(lambda (output)
            (route-child-output child (%call output 'port) (%call output 'datum) connections))
        (%call child 'outputs))
  (%call child 'clear-outputs))

(defun route-child-output (child port datum connections)
  (route child port datum connections))

(defun route-downwards (self port datum connections)
  (route self port datum connections))

(defun route (from port datum connections)
  (let ((from-sender (Sender/new from port)))
    (mapc #'(lambda (conn)
              (cond ((%call conn 'sender-matches? from-sender)
                     (%call conn 'deposit datum))
                    (t nil)))          connections)))

(defun ready? (child)
  (let ((empty-inputs (%call child 'empty-input?))
        (empty-outputs (%call child 'empty-output?)))
    (or (not empty-inputs) (not empty-outputs))))

(defun any-child-ready? (children)
  (some #'ready? children))
