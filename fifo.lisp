(defun FIFO/new ()
  (let ((queue nil))
    (let ((enqueue (lambda (x) (push x queue)))
	  (dequeue (lambda () (cond ((null queue) nil)
				    (t (let ((r (car (last queue))))
					 (setf queue (butlast queue))
					 r)))))
	  (clear (lambda () (setf queue nil)))
	  (empty? (lambda () (null queue)))
          (contents (lambda () queue))
          )
      (let ((namespace `(
                         (enqueue . ,enqueue)
                         (dequeue . ,dequeue)
                         (clear . ,clear)
                         (empty? . ,empty?)
                         (%contents . ,%contents)
                         )))
	namespace))))
